clear
close all
clc

%% Pre-Processing
%Initializations
letters = char(65:90);
N = 26;
sigma = 1.0;
backgroundIm = imread('BackgroundImages(New)/IMG_0257.JPG');
smoothedBackground = GaussianSmoothing(backgroundIm, sigma);
T = .2;

covMatrices = zeros(3, 3, N);

%Only train if no training file saved
if ~isfile('covMatrices.txt')
    
    %for ecah letter
    for i = 1:N
        %find directory for that letter
        currentDirectory = strcat('LetterImages(New)/', letters(i));
        imageFiles = dir(fullfile(currentDirectory, '*.jpg'));
        sz = length(imageFiles);

        sumMatrix = zeros(3, 3);

        %For each image of that letter
        for j = 1:sz
            %read image and smooth
            filename = imageFiles(j).name;
            letterIm = imread(strcat(currentDirectory, '/', filename));
            blurredIm = GaussianSmoothing(letterIm, sigma);

            % Perform background subtraction
            region = BackgroundSubtraction(blurredIm, smoothedBackground, T);
            region = bwmorph(region, 'dilate');
            [L, num] = bwlabel(region, 8);
            region = bwareaopen(L, 500, 8);

            % OLD REGION FINDING
            % Extract window using background subtracted image
            %{
            [rows, columns] = find(region);
            windowLeft = min(columns);
            windowRight = max(columns);
            windowBottom = max(rows);
            windowTop = min(rows);
            

            rowThreshold = 25;
            columnThreshold = 25;
            imageSz = size(blurredIm);
            

            left = max(1, windowLeft-columnThreshold);
            right = min(imageSz(2), windowRight+columnThreshold);
            top = max(1, windowTop-rowThreshold);
            bottom = min(imageSz(1), windowBottom+rowThreshold);

            handRegion = blurredIm(top:bottom, left:right, :);
            %}
            
            %CALCULATION
            %Using features, calculate covariance matrix C model, add result
            %Overlay region to image, convert to grayscale
            handIm = rgb2gray(blurredIm.*region);
            %figure();
            %imshow(handIm);
            
            %get feature vectors of image
            features = GetWindowFeatureVectors(handIm);
            
            %Mean feature vector
            ufkx = mean(features, 1);
            ufk = mean(ufkx,2);
            
            %Calculate covariance
            [R,C] = size(features(:,:,3));
            sum = 0;
            for y = 1:R
                 for x = 1:C
                     sub = features(y,x,:)-ufk;
                     sub = sub(:);
                     sum = sum + (sub)*(sub.');
                 end
             end
             %bias sum, divide by #pixels
             sum = sum/(R*C);

             % to sumMatrix  
             sumMatrix = sumMatrix + sum;
        end

        covMatrices(:, :, i) = sumMatrix / sz;
    end
    
    writematrix(covMatrices, 'covMatrices.txt');
else
    covMatrices = readmatrix('covMatrices.txt');
end




%% Matching

covMatrices = readmatrix('covMatrices.txt');
covMatrices(isnan(covMatrices))=0;
letters = char(65:90);
N = 26;
sigma = 1.0;
T = 0.2;

backgroundIm = imread('BackgroundImages(New)/IMG_0257.JPG');
smoothedBackground = GaussianSmoothing(backgroundIm, sigma);

total = 0;
correct = 0;
for i = 1:N
    currentDirectory = strcat('TestImages/', letters(i));
    imageFiles = dir(fullfile(currentDirectory, '*.jpg'));
    sz = length(imageFiles);
    
    for j = 1:sz
        filename = imageFiles(j).name;
        concat = strcat(currentDirectory, '/', filename);
        letterIm = imread(concat,'jpg');
        blurredIm = GaussianSmoothing(letterIm, sigma);
        %figure();
        %imshow(blurredIm);
        
        % Perform background subtraction
        region = BackgroundSubtraction(blurredIm, smoothedBackground, T);
        region = bwmorph(region, 'dilate');
        [L, num] = bwlabel(region, 8);
        region = bwareaopen(L, 150, 8);
        %figure();
        %imshow(region);
        
        % Extract window using background subtracted image
        [rows, columns] = find(region);
        windowLeft = min(columns);
        windowRight = max(columns);
        windowBottom = max(rows);
        windowTop = min(rows);
        
        rowThreshold = 25;
        columnThreshold = 25;
        sz = size(blurredIm);
        
        left = max(1, windowLeft-columnThreshold);
        right = min(sz(2), windowRight+columnThreshold);
        top = max(1, windowTop-rowThreshold);
        bottom = min(sz(1), windowBottom+rowThreshold);
        
        handRegion = blurredIm(top:bottom, left:right, :);
        
        %CALCULATION
        %Using features, calculate covariance matrix C model, add result
        %Overlay region to image, convert to grayscale
        
        %uses side cropping to region
        %handIm = rgb2gray(handRegion);
        
        %only looks at pixels flagged by region
        handIm = rgb2gray(blurredIm.*region);
        %figure();
        %imshow(handIm);
        
        %get feature vectors of image
        features = GetWindowFeatureVectors(handIm);
        
        %Mean feature vector
        ufkx = mean(features, 1);
        ufk = mean(ufkx,2);
        
        [R,C] = size(features(:,:,3));
        sum = 0;
        for y = 1:R
             for x = 1:C
                 sub = features(y,x,:)-ufk;
                 sub = sub(:);
                 sum = sum + (sub)*(sub.');
             end
        end
        %bias sum, divide by #pixels
        covar = sum/(R*C);

        %CLOSEST MATCH
        distances = []; 
        for l = 1:N
            %for each letter covariance
            %get eigenvalues
            low = l*3-2;
            high = l*3;
            covMatrix = covMatrices(:,low:high);
            vals = eig(covar,covMatrix);
            %get rid of zeros so don't ln(0)
            vals(vals==0)=NaN;
            len = size(vals);
            sum = 0;
            %ln() each eigval, square, then sum
            for p = 1:len(1)
                sum = sum + log(vals(p))^2;
            end
            sum = sqrt(sum);
            %save sqrt'd total
            distances(l) = sum;
        end
        %find minimum distance
        closest = min(distances);
        %index of that minimum distance is index of patch
        result = find(distances==closest);
        fprintf('Actual: %c, Classified: %c\n', letters(i), letters(result));
        if letters(i) == letters(result)
            correct = correct + 1;
        end
        
        total = total + 1;
    end
    
end

fprintf('Classification accuracy: %u/%u\n', correct, total);




%% Reference
% %FOLLOWING CODE IS PULLED FROM HW10 NCC TEMPLATE MATCHING
% left = double(imread('left.png'));
% right = double(imread('right.png'));
% 
% S = 256;
% disparity = zeros([S,S]);
% 
% %I'm assuming the epipolar lines are already paralled
% %they look that way from the images
% %going straight to bottom bullet points on slide 26
% window = 11;
% radius = (window-1)/2;
% 
% %for each pixel in left
% for c = 1+radius:S-radius
%     for r = 1+radius:S-radius
%         xl = left(r,c);
%         lpatch = left(r-radius:r+radius,c-radius:c+radius);
%         left_av = mean(mean(lpatch));
%         left_std = std(lpatch,0,'all');
%         
%         search = min(50,c-(1+radius));
%         best_ncc = 0;
%         best_index = 0;
%         for c2 = 0:search
%             %only need to search to left of rc in right image
%             xr = right(r,c-c2);
%             rpatch = right(r-radius:r+radius,(c-c2)-radius:(c-c2)+radius);
%             right_av = mean(mean(rpatch));
%             right_std = std(rpatch,0,'all');
%             
%             %use ncc to find best pixel in right
%             sum = 0;
%             for x = 1:window
%                 for y = 1:window
%                     sum = sum + ((lpatch(x,y)-left_av)*(rpatch(x,y)-right_av)) / (left_std * right_std);
%                 end
%             end
%             
%             %record largest ncc value
%             ncc = sum/(window*window-1);
%             if ncc > best_ncc
%                 best_ncc = ncc;
%                 best_index = c2;
%             end
%             
%         end
%         
%         match = c-best_index;
%         disparity(r,c) = c-match;
%     end
% end
% 
% figure();
% imagesc(disparity, [0 50]);  
% axis equal; 
% colormap gray; 
% title 'disparity map';


%% Functions

% Performs basic background subtraction using a foreground image, a
% background image, and a threshold (T).
function region = BackgroundSubtraction(foregroundIm, backgroundIm, T)

    % Need to convert images to grayscale
    grayForeground = rgb2gray(foregroundIm);
    grayBackground = rgb2gray(backgroundIm);

    region = abs(grayForeground - grayBackground) > T;

end

% Given a binary region, calculates the average X and Y coordinates
% in the region.
function [X, Y] = CalculateRegionCenter(region)

    X = 0;
    Y = 0;
    count = 0;
    
    sz = size(region);
    for x = 1:sz(2)
        for y = 1:sz(1)
            
            if region(y,x) == 1
                X = X + x;
                Y = Y + y;
                count = count + 1;
            end
            
        end
    end
    
    X = X / XCount;
    Y = Y / YCount;
    
end

% PULLED FROM HW2 CODE
% Performs Gaussian Smoothing.
function smoothedIm = GaussianSmoothing(im, sigma)
    
    % Get smoothing mask
    G = fspecial('gaussian', 2*ceil(3*sigma)+1, sigma);
    
    % Convert image to double type
    im = double(im);
    
    % Apply smoothing mask
    smoothedIm = imfilter(im, G, 'replicate');
    smoothedIm = smoothedIm / 255;
end

% Extracts feature vectors from each pixel within the specified window.
% x - x coordinate of the window center
% y - y coordinate of the window center
function features = GetWindowFeatureVectors(im)
    [R, C] = size(im);
    features = zeros(R, C, 3);
    
    %generate column numbers
    col = 1:C;
    repeat = repelem(col,R);
    repeat = reshape(repeat,[R,C]);
    features(:,:,1) = repeat;
    
    %generate row numbers
    rows = 1:R;
    repeat = repelem(rows,C);
    repeat = transpose(reshape(repeat,[C,R]));
    features(:,:,2) = repeat;
    
    %Generate Greyscale Values
    features(:,:,3) = im;
    
    %I think the below code was slow
    %{
    for x = 1:C
        for y = 1:R
            features(x, y, 1) = x;
            features(x, y, 2) = y;
            features(:, :, 3) = im(x,y);
        end    
    end
    %}
    
end
